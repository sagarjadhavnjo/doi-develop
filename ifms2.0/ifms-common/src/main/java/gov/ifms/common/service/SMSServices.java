package gov.ifms.common.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.KeyManagementException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.net.ssl.SSLContext;

import gov.ifms.common.util.Constant;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

@Service
public class SMSServices {

	@Value("${sms.url}")
	private String smsUrl;

	@Value("${sms.password}")
	private String smsPassword;

	@Value("${sms.username}")
	private String smsUsername;

	@Value("${sms.sender.id}")
	private String smsSenderId;

	@Value("${sms.secure.key}")
	private String smsSecureKey;

	@Value("${sms.service.type}")
	private String smsServiceType;

	@Value("${sms.service.enable}")
	private boolean isSmsServiceEnable;

	public String sendSingleSMS(String username, String password, String message, String senderId, String mobileNumber,
			String secureKey) {
		String responseString = "";
		SSLSocketFactory sf = null;
		SSLContext context = null;
		String encryptedPassword;
		try {
			context = SSLContext.getInstance("TLSv1.2");
			context.init(null, null, null);
			sf = new SSLSocketFactory(context, SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
			Scheme scheme = new Scheme("https", 443, sf);
			HttpClient client = new DefaultHttpClient();
			client.getConnectionManager().getSchemeRegistry().register(scheme);
			HttpPost post = new HttpPost("https://msdgweb.mgov.gov.in/esms/sendsmsrequest");
			encryptedPassword = MD5(password);
			message = message.trim();
			String genratedhashKey = hashGenerator(username, senderId, message, secureKey);
			List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);
			nameValuePairs.add(new BasicNameValuePair("mobileno", mobileNumber));
			nameValuePairs.add(new BasicNameValuePair("senderid", senderId));
			nameValuePairs.add(new BasicNameValuePair("content", message));
			nameValuePairs.add(new BasicNameValuePair("smsservicetype", "singlemsg"));
			nameValuePairs.add(new BasicNameValuePair("username", username));
			nameValuePairs.add(new BasicNameValuePair("password", encryptedPassword));
			nameValuePairs.add(new BasicNameValuePair("key", genratedhashKey));
			post.setEntity(new UrlEncodedFormEntity(nameValuePairs));
			HttpResponse response = client.execute(post);
			BufferedReader bf = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
			String line = "";
			while ((line = bf.readLine()) != null) {
				responseString = responseString + line;
			}
			System.out.println(responseString);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (KeyManagementException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return responseString;
	}

	/**
	 * Send Bulk text SMS
	 * @param username     : Department Login User Name
	 * @param password     : Department Login Password
	 * @param message      : Message e.g. 'Welcome to mobile Seva'
	 * @param senderId     : Department allocated SenderID
	 * @param mobileNumber : Bulk Mobile Number with comma separated e.g.
	 *                     '99XXXXXXX,99XXXXXXXX'
	 * @param secureKey    : Department key generated by login to services
	 *                     portal
	 * @return {@link String} response from Mobile Seva Gateway e.g.
	 *         '402,MsgID = 150620161466003974245msdgsms'
	 * @see <a href="https://mgov.gov.in/msdp_sms_push.jsp">Return types
	 *      code details</a>
	 */
	public String sendBulkSMS(String username, String password, String message, String senderId, String mobileNumber,
			String secureKey) {
		String responseString = "";
		SSLSocketFactory sf = null;
		SSLContext context = null;
		String encryptedPassword;
		try {
			context = SSLContext.getInstance("TLSv1.2");
			context.init(null, null, null);
			sf = new SSLSocketFactory(context, SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
			Scheme scheme = new Scheme("https", 443, sf);
			HttpClient client = new DefaultHttpClient();
			client.getConnectionManager().getSchemeRegistry().register(scheme);
			HttpPost post = new HttpPost("https://msdgweb.mgov.gov.in/esms/sendsmsrequest");
			encryptedPassword = MD5(password);
			message = message.trim();
			String genratedhashKey = hashGenerator(username, senderId, message, secureKey);
			List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);
			nameValuePairs.add(new BasicNameValuePair("bulkmobno", mobileNumber));
			nameValuePairs.add(new BasicNameValuePair("senderid", senderId));
			nameValuePairs.add(new BasicNameValuePair("content", message));
			nameValuePairs.add(new BasicNameValuePair("smsservicetype", "bulkmsg"));
			nameValuePairs.add(new BasicNameValuePair("username", username));
			nameValuePairs.add(new BasicNameValuePair("password", encryptedPassword));
			nameValuePairs.add(new BasicNameValuePair("key", genratedhashKey));
			post.setEntity(new UrlEncodedFormEntity(nameValuePairs));
			HttpResponse response = client.execute(post);
			BufferedReader bf = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
			String line = "";
			while ((line = bf.readLine()) != null) {
				responseString = responseString + line;
			}
			System.out.println(responseString);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (KeyManagementException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return responseString;
	}

	public String sendUnicodeSMS(String username, String password, String message, String senderId, String mobileNumber,
			String secureKey) {
		String finalmessage = "";
		message = message.trim();
		for (int i = 0; i < message.length(); i++) {
			char ch = message.charAt(i);
			int j = (int) ch;
			String sss = "&#" + j + ";";
			finalmessage = finalmessage + sss;
		}
		String responseString = "";
		SSLSocketFactory sf = null;
		SSLContext context = null;
		String encryptedPassword;
		try {
			context = SSLContext.getInstance("TLSv1.2");
			context.init(null, null, null);
			sf = new SSLSocketFactory(context, SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
			Scheme scheme = new Scheme("https", 443, sf);
			HttpClient client = new DefaultHttpClient();
			client.getConnectionManager().getSchemeRegistry().register(scheme);
			HttpPost post = new HttpPost("https://msdgweb.mgov.gov.in/esms/sendsmsrequest");
			encryptedPassword = MD5(password);
			String genratedhashKey = hashGenerator(username, senderId, finalmessage, secureKey);
			List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);
			nameValuePairs.add(new BasicNameValuePair("bulkmobno", mobileNumber));
			nameValuePairs.add(new BasicNameValuePair("senderid", senderId));
			nameValuePairs.add(new BasicNameValuePair("content", finalmessage));
			nameValuePairs.add(new BasicNameValuePair("smsservicetype", "unicodemsg"));
			nameValuePairs.add(new BasicNameValuePair("username", username));
			nameValuePairs.add(new BasicNameValuePair("password", encryptedPassword));
			nameValuePairs.add(new BasicNameValuePair("key", genratedhashKey));
			post.setEntity(new UrlEncodedFormEntity(nameValuePairs));
			HttpResponse response = client.execute(post);
			BufferedReader bf = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
			String line = "";
			while ((line = bf.readLine()) != null) {
				responseString = responseString + line;
			}
			System.out.println(responseString);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (KeyManagementException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return responseString;
	}

	protected String hashGenerator(String userName, String senderId, String content, String secureKey) {
		// TODO Auto-generated method stub
		StringBuffer finalString = new StringBuffer();
		finalString.append(userName.trim()).append(senderId.trim()).append(content.trim()).append(secureKey.trim());
		// logger.info("Parameters for SHA-512 : "+finalString);
		String hashGen = finalString.toString();
		StringBuffer sb = null;
		MessageDigest md;
		try {
			md = MessageDigest.getInstance("SHA-512");
			md.update(hashGen.getBytes());
			byte byteData[] = md.digest();
			// convert the byte to hex format method 1
			sb = new StringBuffer();
			for (int i = 0; i < byteData.length; i++) {
				sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
			}
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	/****
	 * 
	 * Method to convert Normal Plain Text Password to MD5 encrypted password
	 * 
	 ***/
	private static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
		MessageDigest md;
		md = MessageDigest.getInstance("SHA-1");
		byte[] md5 = new byte[64];
		md.update(text.getBytes("iso-8859-1"), 0, text.length());
		md5 = md.digest();
		return convertedToHex(md5);
	}

	private static String convertedToHex(byte[] data) {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < data.length; i++) {
			int halfOfByte = (data[i] >>> 4) & 0x0F;
			int twoHalfBytes = 0;
			do {
				if ((0 <= halfOfByte) && (halfOfByte <= 9)) {
					buf.append((char) ('0' + halfOfByte));
				} else {
					buf.append((char) ('a' + (halfOfByte - 10)));
				}
				halfOfByte = data[i] & 0x0F;
			} while (twoHalfBytes++ < 1);
		}
		return buf.toString();
	}

	public String sendSingleSMS(String mobileNumber, String message) throws UnsupportedEncodingException, NoSuchAlgorithmException {
		if(isSmsServiceEnable) {
			RestTemplate restTemplate = new RestTemplate();
			Map<String, String> urlParams = new HashMap<>();

			UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(this.smsUrl)
					.queryParam(Constant.SMS_PARAM_MO_NO, mobileNumber)
					.queryParam(Constant.SMS_PARAM_SENDER_ID, this.smsSenderId)
					.queryParam(Constant.SMS_PARAM_CONTENT, message)
					.queryParam(Constant.SMS_PARAM_SMSSERVICETYPE, this.smsServiceType)
					.queryParam(Constant.SMS_PARAM_USERNAME, this.smsUsername)
					.queryParam(Constant.SMS_PARAM_PASSWORD, MD5(this.smsPassword))
					.queryParam(Constant.SMS_PARAM_KEY, hashGenerator(this.smsUsername, this.smsSenderId, message, this.smsSecureKey));

			ResponseEntity<String> response = restTemplate.exchange(builder.buildAndExpand(urlParams).toUri(), HttpMethod.POST, null, String.class);
			System.out.println("SMS Sent status = " + response.getBody().trim());
			return response.getBody();
		}
		return StringUtils.EMPTY;
	}

}
